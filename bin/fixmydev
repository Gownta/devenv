#!/usr/bin/python3

"""
fixmydev

Run a series of health checks and remediations on the current server.

Standalone file that can also be used to set up a new server.
"""

"""
TODOs
- 
"""


import argparse
import logging
import getpass
import os
import shlex
import shutil
import subprocess
import sys

from dataclasses import dataclass
from functools import cache


################################################################################
### Configuration
################################################################################


################################################################################
### Args
################################################################################


def get_parser():
    parser = argparse.ArgumentParser(
        prog="fixmydev",
        description="Fix my devserver",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument(
        "--no-color",
        action="store_true",
        help="Disable color in the output",
    )

    parser.add_argument(
        "-i",
        "--interactive",
        action="store_true",
        help="Prompt before running commands",
    )

    return parser


def init_args(argv):
    parser = get_parser()
    global args
    args = parser.parse_args(argv)


################################################################################
### Interaction
################################################################################


def query(msg, valid=None):
    if valid is None:
        valid = ["", "y", "n"]
    while True:
        ans = input(msg)[:1].lower()
        if ans in valid:
            return ans


def color(msg, clr):
    if args.no_color:
        return msg
    return f"\033[38;5;{clr}m{msg}\033[0m"


def run(cmd, check=True, **kwargs):
    if args.interactive:
        pre = "Run command '"
        post = "'? [Y/n] "
    else:
        pre = "Running command '"
        post = "'"
    pre = color(pre, 223)
    post = color(post, 223)
    mid = color(' '.join(shlex.quote(c) for c in cmd), 220)
    whole = pre + mid + post

    if args.interactive:
        ans = query(whole)
        if ans not in ["", "y"]:
            return None
    else:
        print(whole, flush=True)

    return subprocess.run(cmd, check=check, **kwargs)


################################################################################
### Interaction
################################################################################


################################################################################
### Fixups
################################################################################


'''
class FixupFile(Fixup):
    def __init__(self, style, f, name_v=None, owner=None, group=None, perms=None):
        self.style = style[:1]
        assert self.style in ["d", "f"]
        self.descriptor = "directory" if self.style == "d" else "file"

        self.f = f
        self.name_v = name_v or f"{self.descriptor} {f}"
        self.owner = owner or args.unixname
        self.group = group or args.unixname
        self.perms = perms

    def name(self):
        return self.name_v

    def is_good(self):
        ret = subprocess.run(["sudo", "[", "-e", self.f, "]"]).returncode
        return ret == 0

    def explain(self):
        return f"{self.descriptor} {self.f} does not exist"

    def get_fixes(self):
        ret = []

        # Create the file
        if self.style == "f":
            ret.append(SubprocessCommand(f"sudo -u {args.unixname} touch {self.f}"))
            ret.append(SubprocessCommand(f"sudo -u {args.unixname} vim {self.f}"))
        else:
            ret.append(SubprocessCommand(f"sudo -u {args.unixname} mkdir {self.f}"))

        # Set ownership
        #ret.append(SubprocessCommand(f"sudo chown {self.owner}:{self.group} {self.f}"))

        # Set permissions
        if self.perms is not None:
            ret.append(SubprocessCommand(f"sudo chmod {self.perms} {self.f}"))

        return ret


class FixupKeys(Fixup):
    def name(self):
        return "ssh keys"

    def is_good(self):
        return os.path.exists(f"/home/{args.unixname}/.ssh/id_ed25519")

    def explain(self):
        return "No id_ed25519 key present"

    def get_fixes(self):
        return [
            SubprocessCommand(["sudo", "-u", args.unixname, "ssh-keygen", "-t", "ed25519", "-C", "nicholas.ormrod@gmail.com"]),
            SubprocessCommand(["sudo", "cat", f"/home/{args.unixname}/.ssh/id_ed25519.pub"]),
            InstructionCommand("Add this key to github"),
        ]

class FixupGithub(Fixup):
    def __init__(self, repo):
        self.repo = repo
        self.dst = f"/home/{args.unixname}/dev/{self.repo}"

    def name(self):
        return f"github repo {self.repo}"

    def is_good(self):
        return os.path.exists(self.dst)

    def explain(self):
        return f"{self.dst} not found"

    def get_fixes(self):
        return [SubprocessCommand(["sudo", "-u", args.unixname, "git", "clone", f"git@github.com:Gownta/{self.repo}.git", self.dst])]


class FixupSymlink(Fixup):
    def __init__(self, actual, start):
        self.actual = f"/home/{args.unixname}/dev/devenv/{actual}"
        self.start = f"/home/{args.unixname}/{start}"

    def is_good(self):
        return 
'''


################################################################################
### Main
################################################################################


def install_packages(packages):
    print(color("Fetching packages...", 32))
    run(["sudo", "dnf", "install", "-y"] + packages)
    run(["sudo", "dnf", "upgrade"])


def shell_to_zsh(user):
    print(color("Using zsh...", 32))

    passwd = subprocess.run(["getent", "passwd", user], capture_output=True, text=True, check=True).stdout.strip()
    shell = passwd.split(":")[-1]

    if os.path.basename(shell) != "zsh":
        zsh = subprocess.check_output(["which", "zsh"], text=True).strip()
        print(f"Shell is {shell}; switching to zsh ({zsh})")
        run(["sudo", "usermod", "--shell", zsh, user])


def setup_ssh():
    print(color("Configuring ssh...", 32))

    os.makedirs(".ssh", mode=0o700, exist_ok=True)

    auth_keys = ".ssh/authorized_keys"
    print(color(f"Checking {auth_keys}...", 32))
    if not os.path.exists(auth_keys):
        if subprocess.run(["id", "ec2-user"], capture_output=True).returncode == 0:
            fn = "/home/ec2-user/.ssh/authorized_keys"
            res = subprocess.run(["sudo", "cat", fn], capture_output=True, text=True)
            if res.returncode != 0:
                print(color("failed to open {fn}", 196))
            else:
                print("copying authorized_keys from ec2-user")
                content = res.stdout
                with open(auth_keys, "x") as f:
                    f.write(content)
                os.chmod(auth_keys, 0o600)

    print(color("Checking id_ed25519...", 32))
    pub = ".ssh/id_ed25519.pub"
    if not os.path.exists(pub):
        run(["ssh-keygen", "-t", "ed25519", "-C", "nicholas.ormrod@gmail.com"])
        with open(pub) as f:
            content = f.read()
        print(f"Add the following key to github at https://github.com/settings/keys:\n\n  {content}\n")
        input("press any key to continue")


def ssh_agent():
    agent = subprocess.check_output(["ssh-agent", "-s"])

    run(["eval", "$(ssh-agent -s)"



def my_github(my_repos):
    os.makedirs("dev", exist_ok=True)

    for repo in my_repos:
        print(color(f"Cloning {repo}...", 32))
        dst = f"dev/{repo}"
        if not os.path.exists(dst):
            run(["git", "clone", f"git@github.com:Gownta/{repo}.git", dst])


    

if __name__ == "__main__":
    init_args(sys.argv[1:])

    # Ensure this is run as user, and not as root, from the homedir
    cur_user = getpass.getuser()
    assert cur_user != "root", "fixmydev should be run as a sudo-priviledged user"
    os.chdir(os.path.expanduser("~"))

    # Packages
    #install_packages(["git", "zsh", "tmux", "htop"])

    # ssh
    #setup_ssh()
    ssh_agent()

    # Github repos
    my_github(["devenv", "starlang", "values", "hanabi"])

    # Shell to zsh
    #shell_to_zsh(cur_user)

    exit(0)



    q = [
        # ssh
        #FixupFile("d", os.path.join("/home", args.unixname), perms=700),
        #FixupFile("d", os.path.join("/home", args.unixname, ".ssh"), perms=700),
        #FixupFile("f", os.path.join("/home", args.unixname, ".ssh", "authorized_keys"), perms=600),
        #FixupKeys(),

        # repos
        #FixupFile("d", os.path.join("/home", args.unixname, "dev")),
        #FixupGithub("devenv"),

        # dotfiles
        #FixupSymlink("env/aws_linux/zshrc", ".zshrc"),

    ]
    go()
